# -*- coding: utf-8 -*-
"""googlegdgnew.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u1OdLv8WTcgaqR0ry7gxogsPa77NCMap
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import make_pipeline
import pickle

# Load Dataset
file_path = '/content/pass.csv'  # Update this path if needed
data = pd.read_csv(file_path)

# Combine Passage and Question as input, Answer as target
data['input_text'] = data['Passage'] + " " + data['Question']
X = data['input_text']
y = data['Answer']

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Build a pipeline with TF-IDF and Logistic Regression
pipeline = make_pipeline(
    TfidfVectorizer(),
    LogisticRegression(max_iter=1000)
)

# Train the model
pipeline.fit(X_train, y_train)

# Save the model
model_path = "teacher_assistant_model.pkl"
with open(model_path, "wb") as file:
    pickle.dump(pipeline, file)

print(f"Model trained and saved at {model_path}")

import pickle

# Load the trained model
model_path = "teacher_assistant_model.pkl"
with open(model_path, "rb") as file:
    model = pickle.load(file)

# Example usage
test_input = "Kindness is a powerful force... What are some examples of kindness?"
predicted_answer = model.predict([test_input])[0]
print(f"Predicted Answer: {predicted_answer}")

import pickle
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load the trained model
model_path = "teacher_assistant_model.pkl"
with open(model_path, "rb") as file:
    model = pickle.load(file)

# Function to calculate grade based on similarity
def assign_grade(similarity_score):
    if similarity_score > 0.8:
        return "A"
    elif similarity_score > 0.5:
        return "B"
    else:
        return "C"

# Function for feedback
def generate_feedback(correct_answer, student_response, similarity_score):
    if similarity_score > 0.8:
        return "Excellent! Your response closely matches the expected answer."
    elif similarity_score > 0.5:
        return f"Good effort! You captured some key points, but consider including more details like '{correct_answer}'."
    else:
        return f"Your response could be improved. Focus on including key details like '{correct_answer}'."

# CLI Main Program
def main():
    print("=== Welcome to the AI Teacher Assistant ===")
    passage = input("Enter the passage: ")
    question = input("Enter the question: ")
    correct_answer = input("Enter the correct answer: ")
    student_response = input("Enter the student's response: ")

    # Combine passage and question as input to the model
    input_text = passage + " " + question

    # Predict using the model
    predicted_answer = model.predict([input_text])[0]

    # Use cosine similarity to evaluate the student response
    vectorizer = TfidfVectorizer()
    tfidf_matrix = vectorizer.fit_transform([correct_answer, student_response])
    similarity_score = cosine_similarity(tfidf_matrix[0], tfidf_matrix[1])[0][0]
    grade = assign_grade(similarity_score)

    # Generate feedback
    feedback = generate_feedback(correct_answer, student_response, similarity_score)

    # Display results
    print("\n=== Results ===")
    print(f"Predicted Answer: {predicted_answer}")
    print(f"Similarity Score: {similarity_score:.2f}")
    print(f"Grade: {grade}")
    print(f"Feedback: {feedback}")

if __name__ == "__main__":
    main()

import tkinter as tk
from tkinter import messagebox
import pickle
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load the trained model
model_path = "teacher_assistant_model.pkl"
with open(model_path, "rb") as file:
    model = pickle.load(file)

def evaluate():
    # Get input from the user
    passage = entry_passage.get("1.0", tk.END).strip()
    question = entry_question.get("1.0", tk.END).strip()
    correct_answer = entry_correct.get("1.0", tk.END).strip()
    student_response = entry_student.get("1.0", tk.END).strip()

    # Combine passage and question
    input_text = passage + " " + question
    predicted_answer = model.predict([input_text])[0]

    # Evaluate similarity
    vectorizer = TfidfVectorizer()
    tfidf_matrix = vectorizer.fit_transform([correct_answer, student_response])
    similarity_score = cosine_similarity(tfidf_matrix[0], tfidf_matrix[1])[0][0]

    # Assign grade
    grade = "A" if similarity_score > 0.8 else "B" if similarity_score > 0.5 else "C"
    feedback = f"Good effort! Try including more details like '{correct_answer}'." if similarity_score <= 0.8 else "Excellent work!"

    # Display results
    result = f"Grade: {grade}\nSimilarity Score: {similarity_score:.2f}\nFeedback: {feedback}"
    messagebox.showinfo("Evaluation Results", result)

# Load the trained model
model_path = "teacher_assistant_model.pkl"
with open(model_path, "rb") as file:
    model = pickle.load(file)

# Define grading and feedback functions
def assign_grade(similarity_score):
    if similarity_score > 0.8:
        return "A"
    elif similarity_score > 0.5:
        return "B"
    else:
        return "C"

def generate_feedback(correct_answer, student_response, similarity_score):
    if similarity_score > 0.8:
        return "Excellent! Your response closely matches the expected answer."
    elif similarity_score > 0.5:
        return f"Good effort! You captured some key points, but consider including more details like '{correct_answer}'."
    else:
        return f"Your response could be improved. Focus on including key details like '{correct_answer}'."

# Define the main function for grading and feedback
def evaluate_response(passage, question, correct_answer, student_response):
    # Combine passage and question as input to the model
    input_text = passage + " " + question

    # Use the model to predict the answer
    predicted_answer = model.predict([input_text])[0]

    # Calculate similarity between student response and correct answer
    vectorizer = TfidfVectorizer()
    tfidf_matrix = vectorizer.fit_transform([correct_answer, student_response])
    similarity_score = cosine_similarity(tfidf_matrix[0], tfidf_matrix[1])[0][0]

    # Assign grade and generate feedback
    grade = assign_grade(similarity_score)
    feedback = generate_feedback(correct_answer, student_response, similarity_score)

    return predicted_answer, grade, feedback


import gradio as gr  # ✅ Correct Import

# Now define the interface
interface = gr.Interface(
    fn=evaluate_response,
    inputs=[
        gr.Textbox(label="Passage", lines=5, placeholder="Enter the passage here..."),
        gr.Textbox(label="Question", lines=2, placeholder="Enter the question here..."),
        gr.Textbox(label="Correct Answer", lines=2, placeholder="Enter the correct answer here..."),
        gr.Textbox(label="Student Response", lines=2, placeholder="Enter the student response here..."),
    ],
    outputs=[
        gr.Textbox(label="Predicted Answer"),
        gr.Textbox(label="Grade"),
        gr.Textbox(label="Feedback"),
    ],
    title="AI Teacher Assistant",
    description="This application evaluates student responses based on the given passage, question, and correct answer. It predicts the answer, assigns a grade, and provides personalized feedback.",
)

interface.launch()  # ✅ Start the Gradio app

# Launch the Gradio App
if __name__ == "__main__":
    interface.launch()